package gen.parser {
	import sys.io.File;
	import haxe.ds.StringMap;
	import gen.Tools;
	import gen._HaxeType.HaxeType_Impl_;
	import haxe.Http;
class DoxygenParser =;
	object;
		static protected var classx : EReg = new EReg("<!-- doxytag: class=\"(.*?)\" -->","");
		static protected var inheritx : EReg = new EReg("<!-- doxytag: inherits=\"(.*?)\" -->","");
		static protected var memberx : EReg = new EReg("<!-- doxytag: member=\"(.*?)\" ref=\"(.*?)\" args=\"(.*?)\" -->","");
		static protected var retx : EReg = new EReg("<td class=\"memItemLeft\" align=\"right\" valign=\"top\">(.*?)</td><td class=\"memItemRight\" valign=\"bottom\"><a class=\"el\" href=\".*?\">(.*?)</a>","");
		static protected var typex : EReg = new EReg("href=\"(class.*?)\"","");
		static protected function fullURL(url : String,relTo : String) : String (;
			let dom : String = relTo in;
			if(dom.indexOf("/",null) != -1) dom = dom.substr(0,dom.indexOf("/",null));
			let loc : String = relTo in;
			if(loc.indexOf("/",null) != -1) loc = loc.substr(0,loc.lastIndexOf("/",null));
			(;
				let _g : int32 = url.indexOf("/",null) in;
				(;
					let all : int32 = _g in;
					switch(_g) {
					case -1:
					return "" + loc + "/" + url;
					break;
					case 0:
					return "" + dom + "/" + url;
					break;
					default:
					return url;
					break;
					}
				);
			);
		);
		
		static protected function parseClass(url : String,cb : * -> unit) : unit (;
			let h : haxe.Http = new haxe.Http(url) in;
			h.onData = function(cont : String) : unit (;
				let td : * = { } in;
				if(gen.parser.DoxygenParser.classx.match(cont)) td._native = gen.parser.DoxygenParser.classx.matched(1);
				else throw "Could not parse " + url;
				td.name = gen._HaxeType.HaxeType_Impl_.ofNative(td._native);
				let nativeNames : List = td._native.split("::") in;
				let nativeName : String = nativeNames[nativeNames.length - 1] in;
				let rets : List = gen.Tools.matches(cont,gen.parser.DoxygenParser.retx,2) in;
				let retMap : IMap = new haxe.ds.StringMap() in;
				(;
					let _g : int32 = 0 in;
					while(_g < rets.length) (;
						let r : List = rets[_g] in;
						++_g;
						if(StringTools.trim(r[0]).length > 0 && StringTools.trim(r[1]).length > 0) [function() : String {
							var $r : String;
							let v : String = gen._HaxeType.HaxeType_Impl_.ofNative(r[0]) in;
							retMap.set(r[1],v);
							$r = v;
							return $r;
						}()];
					);
				);
				if(gen.parser.DoxygenParser.inheritx.match(cont)) td.extend = gen._HaxeType.HaxeType_Impl_.ofNative(StringTools.htmlUnescape(gen.parser.DoxygenParser.inheritx.matched(1)));
				else td.extend = null;
				let members : List = gen.Tools.matches(cont,gen.parser.DoxygenParser.memberx,3) in;
				td.fields = [];
				td.methods = [];
				(;
					let _g : int32 = 0 in;
					while(_g < members.length) (;
						let m : List = members[_g] in;
						++_g;
						m[2] = StringTools.htmlUnescape(StringTools.trim(m[2]));
						if(m[2].length > 0 && m[2].charAt(0) == "(") (;
							let args : String = m[2].substring(1,m[2].lastIndexOf(")",null)) in;
							let nameps : List = m[0].split("::") in;
							let name : String = nameps[nameps.length - 1] in;
							let ret : String = () in;
							if(retMap.exists(name)) ret = retMap.get(name);
							else ret = null;
							if(name == nativeName || name.substr(1,null) == nativeName && name.charAt(0) == "~") name = "new";
							td.methods.push({ name : name, args : function() : List {
								var $r2 : List;
								let _g1 : List = [] in;
								(;
									let _g2 : int32 = 0 in;
									let _g3 : List = args.split(", ") in;
									while(_g2 < _g3.length) (;
										let a : String = _g3[_g2] in;
										++_g2;
										if(a.length > 0) _g1.push(gen._HaxeType.HaxeType_Impl_.ofNative(a));
									);
								);
								$r2 = _g1;
								return $r2;
							}(), ret : ret});
						);
					);
				);
				cb(td);
			);
			h.request(false);
		);
		
		static public function parseURL(url : String,library : String,cb : * -> unit) : unit (;
			let p : * = { types : [], library : library, cffi : "project/common/ExternalInterface.cpp"} in;
			let cont : String = haxe.Http.requestUrl(url) in;
			sys.io.File.saveContent("cont.html",cont);
			let urls : List = () in;
			(;
				let _g : List = [] in;
				(;
					let _g1 : int32 = 0 in;
					let _g2 : List = gen.Tools.matches(cont,gen.parser.DoxygenParser.typex,1) in;
					while(_g1 < _g2.length) (;
						let m : List = _g2[_g1] in;
						++_g1;
						if(m[0] != "classes.html") _g.push(gen.parser.DoxygenParser.fullURL(m[0],url));
					);
				);
				urls = _g;
			);
			(;
				let _g1 : int32 = 0 in;
				while(_g1 < urls.length) (;
					let u : String = urls[_g1] in;
					++_g1;
					gen.parser.DoxygenParser.parseClass(u,function(t : *) : unit (;
						Sys.println("Parsed " + Std.string(t.name));
						p.types.push(t);
						cb(p);
					));
				);
			);
			while(p.types.length < urls.length) Sys.sleep(0.1);
		);
		
end;
	